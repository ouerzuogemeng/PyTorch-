### 协同过滤算法总结
* 基于基线的协同过滤算法：
>预测值=所有用户对该商品的平均打分+该用户对全部商品的平均打分-平均分
* item-based协同过滤算法(相似度未归一化) 
>预测值=（该用户的全部已打分商品 * 该商品与已打分商品的相似度）点积/该商品与已打分商品的相似度之和  
>已打分=(非0评分)
* 结合基线算法的item-based协同过滤算法(相似度未归一化)
>预测值=((该用户的全部已打分商品-baseline[该用户打分商品]) * 该商品与已打分商品的相似度 )点积/(该商品与已打分商品相似度之和)+baseline[item]
        baseline=商品的平均分矩阵+该用户的平均分-总平均分   
        得到的还是一个商品评分矩阵，只是每个点+用户评分-总评分
* user-based协同过滤算法(相似度未归一化) 
>用户在该商品上的预测值=(该商品的用户评分*该用户与其他对该商品打分用户的相似度)点积/该用户与其他对该商品打分用户的相似度之和
* 结合基线算法的user-based协同过滤算法(相似度未归一化)
> 预测值 = (该商品的用户评分 * 该用户与对该商品评分用户的相似度-baseline[该商品打分用户])点积/(该用户与对该商品评分用户的相似度之和) + baseline[user]
        baseline = 用户的平均分矩阵+该商品的平均分-总平均分
* ----  经过修正后的协同过滤 ----
> pretition >5 : then =5 ; pretition<1 then =1
* TOP-K协同过滤(item_based + baseline)
> 预测值 = (该用户top_k打分商品* 该商品与该用户top_k商品的相似度 - baseline[该用户的top_k打分商品])点积/该商品与该用户top_k打分商品相似度之和 + baseline[user]
   
   >     该用户top_k打分商品：用户已打分商品中，打分最高的K个商品
   >     baseline = 商品的平均分矩阵 + 该用户的平均分 - 总平均分
   >     对pretition进行修正
* ------ baseline + item-based + TopK + 归一化矩阵 ------
>  * 运用person相关系数计算相似度矩阵：先进行归一化操作
    * （评分矩阵 - 用户(or商品)的平均分）* （评分矩阵 - 用户(or商品)的平均分）.T  +  epsilon 
    * epsilon: 一个极小值，防止分母异常
    * 进行相似度计算
    * 输出 item & user 的相似度矩阵
   
   >* 进行TOP-K协同过滤(item_based + baseline)
   
